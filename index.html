<html>
<head>
	<title>Contas Refeitas</title>
	<script src="http://d3js.org/d3.v2.js"></script>
	<script src="javascript/fake-data.js"></script>
</head>

<style type="text/css">
	body {
	    margin: 1em;
	}
    
	.node {
	  stroke: #fff;
	  stroke-width: 2px;
	}

	.link {
	  fill: none;
	  stroke: #000;
	  opacity: .3;
	}
	.link.on {
	  stroke: #F00;
	  opacity: .7;
	}

	.node {
	    stroke: none;
	}

</style>

<body>
	
<script>
	Object.prototype.keys = function() {
		var keys = [];
		for (var key in json)
			keys.push(key);
		return keys;
	};
	
	
	var data = (function() {
	            var times = [];
	            var allLinks = [];
	            var counter = 0;
							addRoot = function() {
	                var nodes = d3.range(0, 1).map(function(n) {
                       return {
                           id: counter++,
                           nodeName: "Node " + n,
                           nodeValue: total,
                           incoming: []
                       }
                   });
	                times.push(nodes);
	                return nodes;
	            },
							addFirstIteration = function() {
	                var nodes = d3.range(0, json.keys().length).map(function(n) {
	                  return {
	                    id: counter++,
	                    nodeName: "Node " + n,
	                    nodeValue: json[json.keys()[n]],
	                    incoming: []
	                  };
	              	});
	                times.push(nodes);
	                return nodes;
	            },
	            addNext = function() {
	                var current = times[times.length-1];
	                var nextt = addFirstIteration();
	                // make links
	                current.forEach(function(n) {
                    var links = {};
                    for (var x = 0; x < nextt.length - 1; x++) {
											var target = nextt[x];
                      var link = {
                          source: n.id,
                          target: target.id,
                          value: target.nodeValue
                      };
                      links[target.id] = link;
                      allLinks.push(link);
                    }
	                });
	                // prune next
	                times[times.length-1] = nextt.filter(function(n) { return n.nodeValue });
	            }
	        // initial set
	        addRoot()
	        // now add rest
	        for (var t=0; t < 1; t++) {
	            addNext();
	        }

	        return {
	            times: times,
	            links: allLinks
	        };
	    })();

	/* Process Data */

	// make a node lookup map
	var nodeMap = (function() {
	    var nm = {};
	    data.times.forEach(function(nodes) {
	        nodes.forEach(function(n) {
	            nm[n.id] = n;
	            // add links and assure node value
	            n.links = [];
	            n.incoming = [];
	            n.nodeValue = n.nodeValue || 0;
	        })
	    });
	    return nm;
	})();

	// attach links to nodes
	data.links.forEach(function(link) {
	    nodeMap[link.source].links.push(link);
	    nodeMap[link.target].incoming.push(link);
	});

	// sort by value and calculate offsets
	data.times.forEach(function(nodes) {
	    var cumValue = 0;
	    nodes.sort(function(a,b) {
	        return d3.descending(a.nodeValue, b.nodeValue)
	    });
	    nodes.forEach(function(n, i) {
	        n.order = i;
	        n.offsetValue = cumValue;
	        cumValue += n.nodeValue;
	        // same for links
	        var lCumValue;
	        // outgoing
	        if (n.links) {
	            lCumValue = 0;
	            n.links.sort(function(a,b) {
	                return d3.descending(a.value, b.value)
	            });
	            n.links.forEach(function(l) {
	                l.outOffset = lCumValue;
	                lCumValue += l.value;
	            });
	        }
	        // incoming
	        if (n.incoming) {
	            lCumValue = 0;
	            n.incoming.sort(function(a,b) {
	                return d3.descending(a.value, b.value)
	            });
	            n.incoming.forEach(function(l) {
	                l.inOffset = lCumValue;
	                lCumValue += l.value;
	            });
	        }
	    })
	});
	data = data.times;

	// calculate maxes
	var maxn = d3.max(data, function(t) { return t.length }),
	    maxv = d3.max(data, function(t) { return d3.sum(t, function(n) { return n.nodeValue }) });

	/* Make Vis */

	// settings and scales
	var w = 1400,
	    h = 500,
	    gapratio = .7,
	    delay = 1500,
	    padding = 15,
	    x = d3.scale.ordinal()
	        .domain(d3.range(data.length))
	        .rangeBands([0, w + (w/(data.length-1))], gapratio),
	    y = d3.scale.linear()
	        .domain([0, maxv])
	        .range([0, h - padding * maxn]),
	    line = d3.svg.line()
	        .interpolate('basis');

	// root
	var vis = d3.select("body")
	  .append("svg:svg")
	    .attr("width", w)
	    .attr("height", h);


	var t = 0;
	function update(first) {
	    // update data
	    var currentData = data.slice(0, ++t);

	    // time slots
	    var times = vis.selectAll('g.time')
	        .data(currentData)
	      .enter().append('svg:g')
	        .attr('class', 'time')
	        .attr("transform", function(d, i) { return "translate(" + (x(i) - x(0)) + ",0)" });

	    // node bars
	    var nodes = times.selectAll('g.node')
	        .data(function(d) { return d })
	      .enter().append('svg:g')
	        .attr('class', 'node');

	    setTimeout(function() {
	        nodes.append('svg:rect')
	            .attr('fill', 'steelblue')
	            .attr('y', function(n, i) {
	                return y(n.offsetValue) + i * padding;
	            })
	            .attr('width', x.rangeBand())
	            .attr('height', function(n) { return y(n.nodeValue) })
	          .append('svg:title')
	            .text(function(n) { return n.nodeName });
	    }, (first ? 0 : delay));

	    var linkLine = function(start) {
	        return function(l) {
	            var source = nodeMap[l.source],
	                target = nodeMap[l.target],
	                gapWidth = x(0),
	                bandWidth = x.rangeBand() + gapWidth,
	                startx = x.rangeBand() - bandWidth,
	                sourcey = y(source.offsetValue) + 
	                    source.order * padding +
	                    y(l.outOffset) +
	                    y(l.value)/2,
	                targety = y(target.offsetValue) + 
	                    target.order * padding + 
	                    y(l.inOffset) +
	                    y(l.value)/2,
	                points = start ? 
	                    [
	                        [ startx, sourcey ], [ startx, sourcey ], [ startx, sourcey ], [ startx, sourcey ] 
	                    ] :
	                    [
	                        [ startx, sourcey ],
	                        [ startx + gapWidth/2, sourcey ],
	                        [ startx + gapWidth/2, targety ],
	                        [ 0, targety ]
	                    ];
	            return line(points);
	        }
	    }

	    // links
	    var links = nodes.selectAll('path.link')
	        .data(function(n) { return n.incoming || [] })
	      .enter().append('svg:path')
	        .attr('class', 'link')
	        .style('stroke-width', function(l) { return y(l.value) })
	        .attr('d', linkLine(true))
	        .on('mouseover', function() {
	            d3.select(this).attr('class', 'link on')
	        })
	        .on('mouseout', function() {
	            d3.select(this).attr('class', 'link')
	        })
	      .transition()
	        .duration(delay)
	        .attr('d', linkLine());

	}

	function updateNext() {
	    if (t < data.length) {
	        update();
	        window.setTimeout(updateNext, delay)
	    }
	}
	update(true);
	updateNext();

	
</script>	
</body>
</html>